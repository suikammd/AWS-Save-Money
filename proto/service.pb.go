// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

package proto

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Request struct {
	Line                 []byte   `protobuf:"bytes,1,opt,name=line,proto3" json:"line,omitempty"`
	Ack                  bool     `protobuf:"varint,2,opt,name=ack,proto3" json:"ack,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{0}
}

func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetLine() []byte {
	if m != nil {
		return m.Line
	}
	return nil
}

func (m *Request) GetAck() bool {
	if m != nil {
		return m.Ack
	}
	return false
}

type Response struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{1}
}

func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Request)(nil), "proto.Request")
	proto.RegisterType((*Response)(nil), "proto.Response")
}

func init() { proto.RegisterFile("service.proto", fileDescriptor_a0b84a42fa06f626) }

var fileDescriptor_a0b84a42fa06f626 = []byte{
	// 197 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x8d, 0x3d, 0xae, 0x82, 0x40,
	0x10, 0x80, 0x1f, 0xbc, 0x3f, 0x32, 0x81, 0xf7, 0xc8, 0x54, 0xc4, 0x8a, 0x50, 0x51, 0x61, 0xc4,
	0x18, 0x0f, 0x20, 0x8d, 0x85, 0xcd, 0x12, 0x0f, 0x00, 0xeb, 0x98, 0x6c, 0x24, 0xbb, 0xb8, 0xbb,
	0x62, 0xbc, 0x8b, 0x87, 0x35, 0x82, 0xb1, 0xdf, 0x6a, 0xbe, 0x99, 0xe4, 0x9b, 0x0f, 0x22, 0x43,
	0x7a, 0x10, 0x9c, 0x8a, 0x5e, 0x2b, 0xab, 0xf0, 0x7b, 0x1c, 0xd9, 0x1c, 0x7e, 0x19, 0x9d, 0x2f,
	0x64, 0x2c, 0x22, 0x7c, 0x75, 0x42, 0x52, 0xe2, 0xa5, 0x5e, 0x1e, 0xb2, 0x91, 0x31, 0x86, 0xcf,
	0x86, 0x9f, 0x12, 0x3f, 0xf5, 0xf2, 0x80, 0x3d, 0x31, 0x03, 0x08, 0x18, 0x99, 0x5e, 0x49, 0x43,
	0xe5, 0xdd, 0x87, 0xb0, 0x26, 0x3d, 0x90, 0xde, 0x74, 0x82, 0xa4, 0xc5, 0x12, 0xa2, 0xda, 0x36,
	0xda, 0x6e, 0xa5, 0xb1, 0x8d, 0xe4, 0x84, 0x7f, 0x53, 0xad, 0x78, 0x35, 0x66, 0xff, 0xef, 0x7d,
	0x7a, 0x91, 0x7d, 0xe0, 0x0a, 0xe2, 0x8a, 0x0c, 0xd7, 0xa2, 0x25, 0x17, 0x6d, 0x01, 0x61, 0x6d,
	0x55, 0xef, 0x58, 0xda, 0xa9, 0x83, 0x38, 0xde, 0xf6, 0x4e, 0xda, 0x1a, 0x70, 0xd2, 0x2a, 0x75,
	0x95, 0x0e, 0x62, 0xfb, 0x33, 0x5e, 0x96, 0x8f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xec, 0x09, 0x9e,
	0x71, 0x7a, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ServerClientClient is the client API for ServerClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ServerClientClient interface {
	StartInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	DescribeInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	StopInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	ModifyUpInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
	ModifyDownInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type serverClientClient struct {
	cc *grpc.ClientConn
}

func NewServerClientClient(cc *grpc.ClientConn) ServerClientClient {
	return &serverClientClient{cc}
}

func (c *serverClientClient) StartInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/proto.ServerClient/StartInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClientClient) DescribeInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/proto.ServerClient/DescribeInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClientClient) StopInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/proto.ServerClient/StopInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClientClient) ModifyUpInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/proto.ServerClient/ModifyUpInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClientClient) ModifyDownInstance(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/proto.ServerClient/ModifyDownInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServerClientServer is the server API for ServerClient service.
type ServerClientServer interface {
	StartInstance(context.Context, *Request) (*Response, error)
	DescribeInstance(context.Context, *Request) (*Response, error)
	StopInstance(context.Context, *Request) (*Response, error)
	ModifyUpInstance(context.Context, *Request) (*Response, error)
	ModifyDownInstance(context.Context, *Request) (*Response, error)
}

// UnimplementedServerClientServer can be embedded to have forward compatible implementations.
type UnimplementedServerClientServer struct {
}

func (*UnimplementedServerClientServer) StartInstance(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartInstance not implemented")
}
func (*UnimplementedServerClientServer) DescribeInstance(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeInstance not implemented")
}
func (*UnimplementedServerClientServer) StopInstance(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopInstance not implemented")
}
func (*UnimplementedServerClientServer) ModifyUpInstance(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyUpInstance not implemented")
}
func (*UnimplementedServerClientServer) ModifyDownInstance(ctx context.Context, req *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyDownInstance not implemented")
}

func RegisterServerClientServer(s *grpc.Server, srv ServerClientServer) {
	s.RegisterService(&_ServerClient_serviceDesc, srv)
}

func _ServerClient_StartInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerClientServer).StartInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ServerClient/StartInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerClientServer).StartInstance(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerClient_DescribeInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerClientServer).DescribeInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ServerClient/DescribeInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerClientServer).DescribeInstance(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerClient_StopInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerClientServer).StopInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ServerClient/StopInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerClientServer).StopInstance(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerClient_ModifyUpInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerClientServer).ModifyUpInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ServerClient/ModifyUpInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerClientServer).ModifyUpInstance(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServerClient_ModifyDownInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerClientServer).ModifyDownInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.ServerClient/ModifyDownInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerClientServer).ModifyDownInstance(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

var _ServerClient_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.ServerClient",
	HandlerType: (*ServerClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartInstance",
			Handler:    _ServerClient_StartInstance_Handler,
		},
		{
			MethodName: "DescribeInstance",
			Handler:    _ServerClient_DescribeInstance_Handler,
		},
		{
			MethodName: "StopInstance",
			Handler:    _ServerClient_StopInstance_Handler,
		},
		{
			MethodName: "ModifyUpInstance",
			Handler:    _ServerClient_ModifyUpInstance_Handler,
		},
		{
			MethodName: "ModifyDownInstance",
			Handler:    _ServerClient_ModifyDownInstance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service.proto",
}
